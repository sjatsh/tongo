package liteclient

// Code autogenerated. DO NOT EDIT.

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"github.com/sjatsh/tongo/tl"
	"io"
)

type TonNodeBlockIdC struct {
	Workchain uint32
	Shard     uint64
	Seqno     uint32
}

func (t TonNodeBlockIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Seqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeBlockIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Seqno)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeBlockIdExtC struct {
	Workchain uint32
	Shard     uint64
	Seqno     uint32
	RootHash  tl.Int256
	FileHash  tl.Int256
}

func (t TonNodeBlockIdExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Seqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeBlockIdExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Seqno)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeZeroStateIdExtC struct {
	Workchain uint32
	RootHash  tl.Int256
	FileHash  tl.Int256
}

func (t TonNodeZeroStateIdExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeZeroStateIdExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeShardPublicOverlayIdC struct {
	Workchain         uint32
	Shard             uint64
	ZeroStateFileHash tl.Int256
}

func (t TonNodeShardPublicOverlayIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ZeroStateFileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeShardPublicOverlayIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ZeroStateFileHash)
	if err != nil {
		return err
	}
	return nil
}

type AdnlMessage struct {
	tl.SumType
	AdnlMessageQuery struct {
		QueryId tl.Int256
		Query   []byte
	}
	AdnlMessageAnswer struct {
		QueryId tl.Int256
		Answer  []byte
	}
}

func (t AdnlMessage) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	switch t.SumType {
	case "AdnlMessageQuery":
		b, err = tl.Marshal(uint32(0xb48bf97a))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.AdnlMessageQuery.QueryId)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.AdnlMessageQuery.Query)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	case "AdnlMessageAnswer":
		b, err = tl.Marshal(uint32(0xfac8416))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.AdnlMessageAnswer.QueryId)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.AdnlMessageAnswer.Answer)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("invalid sum type")
	}
	return buf.Bytes(), nil
}

func (t *AdnlMessage) UnmarshalTL(r io.Reader) error {
	var err error
	var b [4]byte
	_, err = io.ReadFull(r, b[:])
	if err != nil {
		return err
	}
	tag := int(binary.LittleEndian.Uint32(b[:]))
	switch tag {
	case 0xb48bf97a:
		t.SumType = "AdnlMessageQuery"
		err = tl.Unmarshal(r, &t.AdnlMessageQuery.QueryId)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.AdnlMessageQuery.Query)
		if err != nil {
			return err
		}
	case 0xfac8416:
		t.SumType = "AdnlMessageAnswer"
		err = tl.Unmarshal(r, &t.AdnlMessageAnswer.QueryId)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.AdnlMessageAnswer.Answer)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("invalid tag")
	}
	return nil
}

type LiteServerErrorC struct {
	Code    uint32
	Message string
}

func (t LiteServerErrorC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Code)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Message)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerErrorC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Code)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Message)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAccountIdC struct {
	Workchain uint32
	Id        tl.Int256
}

func (t LiteServerAccountIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAccountIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryEntryC struct {
	Hash tl.Int256
	Data []byte
}

func (t LiteServerLibraryEntryC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Hash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryEntryC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Hash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerMasterchainInfoC struct {
	Last          TonNodeBlockIdExtC
	StateRootHash tl.Int256
	Init          TonNodeZeroStateIdExtC
}

func (t LiteServerMasterchainInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Last)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateRootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Init)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerMasterchainInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Last)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateRootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Init)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerMasterchainInfoExtC struct {
	Mode          uint32
	Version       uint32
	Capabilities  uint64
	Last          TonNodeBlockIdExtC
	LastUtime     uint32
	Now           uint32
	StateRootHash tl.Int256
	Init          TonNodeZeroStateIdExtC
}

func (t LiteServerMasterchainInfoExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Version)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Capabilities)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Last)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.LastUtime)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateRootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Init)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerMasterchainInfoExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Version)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Capabilities)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Last)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.LastUtime)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateRootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Init)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerCurrentTimeC struct {
	Now uint32
}

func (t LiteServerCurrentTimeC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerCurrentTimeC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerVersionC struct {
	Mode         uint32
	Version      uint32
	Capabilities uint64
	Now          uint32
}

func (t LiteServerVersionC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Version)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Capabilities)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerVersionC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Version)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Capabilities)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockDataC struct {
	Id   TonNodeBlockIdExtC
	Data []byte
}

func (t LiteServerBlockDataC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockDataC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockStateC struct {
	Id       TonNodeBlockIdExtC
	RootHash tl.Int256
	FileHash tl.Int256
	Data     []byte
}

func (t LiteServerBlockStateC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockStateC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockHeaderC struct {
	Id          TonNodeBlockIdExtC
	Mode        uint32
	HeaderProof []byte
}

func (t LiteServerBlockHeaderC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.HeaderProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockHeaderC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.HeaderProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSendMsgStatusC struct {
	Status uint32
}

func (t LiteServerSendMsgStatusC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Status)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSendMsgStatusC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Status)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAccountStateC struct {
	Id         TonNodeBlockIdExtC
	Shardblk   TonNodeBlockIdExtC
	ShardProof []byte
	Proof      []byte
	State      []byte
}

func (t LiteServerAccountStateC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.State)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAccountStateC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.State)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerRunMethodResultC struct {
	Mode       uint32
	Id         TonNodeBlockIdExtC
	Shardblk   TonNodeBlockIdExtC
	ShardProof []byte
	Proof      []byte
	StateProof []byte
	InitC7     []byte
	LibExtras  []byte
	ExitCode   uint32
	Result     []byte
}

func (t LiteServerRunMethodResultC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.ShardProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Proof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.StateProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>3)&1 == 1 {
		b, err = tl.Marshal(t.InitC7)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>4)&1 == 1 {
		b, err = tl.Marshal(t.LibExtras)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	b, err = tl.Marshal(t.ExitCode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Result)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerRunMethodResultC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempShardProof []byte
		err = tl.Unmarshal(r, &tempShardProof)
		if err != nil {
			return err
		}
		t.ShardProof = tempShardProof
	}
	if (t.Mode>>0)&1 == 1 {
		var tempProof []byte
		err = tl.Unmarshal(r, &tempProof)
		if err != nil {
			return err
		}
		t.Proof = tempProof
	}
	if (t.Mode>>1)&1 == 1 {
		var tempStateProof []byte
		err = tl.Unmarshal(r, &tempStateProof)
		if err != nil {
			return err
		}
		t.StateProof = tempStateProof
	}
	if (t.Mode>>3)&1 == 1 {
		var tempInitC7 []byte
		err = tl.Unmarshal(r, &tempInitC7)
		if err != nil {
			return err
		}
		t.InitC7 = tempInitC7
	}
	if (t.Mode>>4)&1 == 1 {
		var tempLibExtras []byte
		err = tl.Unmarshal(r, &tempLibExtras)
		if err != nil {
			return err
		}
		t.LibExtras = tempLibExtras
	}
	err = tl.Unmarshal(r, &t.ExitCode)
	if err != nil {
		return err
	}
	if (t.Mode>>2)&1 == 1 {
		var tempResult []byte
		err = tl.Unmarshal(r, &tempResult)
		if err != nil {
			return err
		}
		t.Result = tempResult
	}
	return nil
}

type LiteServerShardInfoC struct {
	Id         TonNodeBlockIdExtC
	Shardblk   TonNodeBlockIdExtC
	ShardProof []byte
	ShardDescr []byte
}

func (t LiteServerShardInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardDescr)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardDescr)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAllShardsInfoC struct {
	Id    TonNodeBlockIdExtC
	Proof []byte
	Data  []byte
}

func (t LiteServerAllShardsInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAllShardsInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionInfoC struct {
	Id          TonNodeBlockIdExtC
	Proof       []byte
	Transaction []byte
}

func (t LiteServerTransactionInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transaction)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transaction)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionListC struct {
	Ids          []TonNodeBlockIdExtC
	Transactions []byte
}

func (t LiteServerTransactionListC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Ids)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transactions)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionListC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Ids)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transactions)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionIdC struct {
	Mode    uint32
	Account *tl.Int256
	Lt      *uint64
	Hash    *tl.Int256
}

func (t LiteServerTransactionIdC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Account)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Hash)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionIdC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempAccount tl.Int256
		err = tl.Unmarshal(r, &tempAccount)
		if err != nil {
			return err
		}
		t.Account = &tempAccount
	}
	if (t.Mode>>1)&1 == 1 {
		var tempLt uint64
		err = tl.Unmarshal(r, &tempLt)
		if err != nil {
			return err
		}
		t.Lt = &tempLt
	}
	if (t.Mode>>2)&1 == 1 {
		var tempHash tl.Int256
		err = tl.Unmarshal(r, &tempHash)
		if err != nil {
			return err
		}
		t.Hash = &tempHash
	}
	return nil
}

type LiteServerTransactionId3C struct {
	Account tl.Int256
	Lt      uint64
}

func (t LiteServerTransactionId3C) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionId3C) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Lt)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockTransactionsC struct {
	Id         TonNodeBlockIdExtC
	ReqCount   uint32
	Incomplete bool
	Ids        []LiteServerTransactionIdC
	Proof      []byte
}

func (t LiteServerBlockTransactionsC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ReqCount)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Incomplete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Ids)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockTransactionsC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ReqCount)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Incomplete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Ids)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockTransactionsExtC struct {
	Id           TonNodeBlockIdExtC
	ReqCount     uint32
	Incomplete   bool
	Transactions []byte
	Proof        []byte
}

func (t LiteServerBlockTransactionsExtC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ReqCount)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Incomplete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transactions)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockTransactionsExtC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ReqCount)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Incomplete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transactions)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSignatureC struct {
	NodeIdShort tl.Int256
	Signature   []byte
}

func (t LiteServerSignatureC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.NodeIdShort)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Signature)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSignatureC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.NodeIdShort)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Signature)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSignatureSetC struct {
	ValidatorSetHash uint32
	CatchainSeqno    uint32
	Signatures       []LiteServerSignatureC
}

func (t LiteServerSignatureSetC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.ValidatorSetHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.CatchainSeqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Signatures)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSignatureSetC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.ValidatorSetHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.CatchainSeqno)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Signatures)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockLink struct {
	tl.SumType
	LiteServerBlockLinkBack struct {
		ToKeyBlock bool
		From       TonNodeBlockIdExtC
		To         TonNodeBlockIdExtC
		DestProof  []byte
		Proof      []byte
		StateProof []byte
	}
	LiteServerBlockLinkForward struct {
		ToKeyBlock  bool
		From        TonNodeBlockIdExtC
		To          TonNodeBlockIdExtC
		DestProof   []byte
		ConfigProof []byte
		Signatures  LiteServerSignatureSet
	}
}

func (t LiteServerBlockLink) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	switch t.SumType {
	case "LiteServerBlockLinkBack":
		b, err = tl.Marshal(uint32(0xef7e1bef))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.ToKeyBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.From)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.To)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.DestProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.Proof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.StateProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	case "LiteServerBlockLinkForward":
		b, err = tl.Marshal(uint32(0x520fce1c))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.ToKeyBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.From)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.To)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.DestProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.ConfigProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.Signatures)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("invalid sum type")
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockLink) UnmarshalTL(r io.Reader) error {
	var err error
	var b [4]byte
	_, err = io.ReadFull(r, b[:])
	if err != nil {
		return err
	}
	tag := int(binary.LittleEndian.Uint32(b[:]))
	switch tag {
	case 0xef7e1bef:
		t.SumType = "LiteServerBlockLinkBack"
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.ToKeyBlock)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.From)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.To)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.DestProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.Proof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.StateProof)
		if err != nil {
			return err
		}
	case 0x520fce1c:
		t.SumType = "LiteServerBlockLinkForward"
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.ToKeyBlock)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.From)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.To)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.DestProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.ConfigProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.Signatures)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("invalid tag")
	}
	return nil
}

type LiteServerPartialBlockProofC struct {
	Complete bool
	From     TonNodeBlockIdExtC
	To       TonNodeBlockIdExtC
	Steps    []LiteServerBlockLink
}

func (t LiteServerPartialBlockProofC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Complete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.From)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.To)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Steps)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerPartialBlockProofC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Complete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.From)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.To)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Steps)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerConfigInfoC struct {
	Mode        uint32
	Id          TonNodeBlockIdExtC
	StateProof  []byte
	ConfigProof []byte
}

func (t LiteServerConfigInfoC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ConfigProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerConfigInfoC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ConfigProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerValidatorStatsC struct {
	Mode       uint32
	Id         TonNodeBlockIdExtC
	Count      uint32
	Complete   bool
	StateProof []byte
	DataProof  []byte
}

func (t LiteServerValidatorStatsC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Complete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.DataProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerValidatorStatsC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Count)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Complete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.DataProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryResultC struct {
	Result []LiteServerLibraryEntryC
}

func (t LiteServerLibraryResultC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Result)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryResultC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Result)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryResultWithProofC struct {
	Id         TonNodeBlockIdExtC
	Mode       uint32
	Result     []LiteServerLibraryEntryC
	StateProof []byte
	DataProof  []byte
}

func (t LiteServerLibraryResultWithProofC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Result)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.DataProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryResultWithProofC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Result)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.DataProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerShardBlockLinkC struct {
	Id    TonNodeBlockIdExtC
	Proof []byte
}

func (t LiteServerShardBlockLinkC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardBlockLinkC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerShardBlockProofC struct {
	MasterchainId TonNodeBlockIdExtC
	Links         []LiteServerShardBlockLinkC
}

func (t LiteServerShardBlockProofC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.MasterchainId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Links)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardBlockProofC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.MasterchainId)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Links)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLookupBlockResultC struct {
	Id                 TonNodeBlockIdExtC
	Mode               uint32
	McBlockId          TonNodeBlockIdExtC
	ClientMcStateProof []byte
	McBlockProof       []byte
	ShardLinks         []LiteServerShardBlockLinkC
	Header             []byte
	PrevHeader         []byte
}

func (t LiteServerLookupBlockResultC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.McBlockId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ClientMcStateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.McBlockProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardLinks)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Header)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.PrevHeader)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLookupBlockResultC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.McBlockId)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ClientMcStateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.McBlockProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardLinks)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Header)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.PrevHeader)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerOutMsgQueueSizeC struct {
	Id   TonNodeBlockIdExtC
	Size uint32
}

func (t LiteServerOutMsgQueueSizeC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Size)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerOutMsgQueueSizeC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Size)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerOutMsgQueueSizesC struct {
	Shards               []LiteServerOutMsgQueueSizeC
	ExtMsgQueueSizeLimit uint32
}

func (t LiteServerOutMsgQueueSizesC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Shards)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ExtMsgQueueSizeLimit)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerOutMsgQueueSizesC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Shards)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ExtMsgQueueSizeLimit)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerDebugVerbosityC struct {
	Value uint32
}

func (t LiteServerDebugVerbosityC) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Value)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerDebugVerbosityC) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Value)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetMasterchainInfo(ctx context.Context) (res LiteServerMasterchainInfoC, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x89b5e62e)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x85832881 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetMasterchainInfoExtRequest struct {
	Mode uint32
}

func (t LiteServerGetMasterchainInfoExtRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetMasterchainInfoExt(ctx context.Context, request LiteServerGetMasterchainInfoExtRequest) (res LiteServerMasterchainInfoExtC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetMasterchainInfoExtRequest `tlSumType:"70a671df"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa8cce0f5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

func (c *Client) LiteServerGetTime(ctx context.Context) (res LiteServerCurrentTimeC, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x16ad5a34)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xe953000d {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

func (c *Client) LiteServerGetVersion(ctx context.Context) (res LiteServerVersionC, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x232b940b)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x5a0491e5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetBlockRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetBlock(ctx context.Context, request LiteServerGetBlockRequest) (res LiteServerBlockDataC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockRequest `tlSumType:"6377cf0d"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa574ed6c {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetStateRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetStateRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetState(ctx context.Context, request LiteServerGetStateRequest) (res LiteServerBlockStateC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetStateRequest `tlSumType:"ba6e2eb6"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xabaddc0c {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockHeaderRequest struct {
	Id   TonNodeBlockIdExtC
	Mode uint32
}

func (t LiteServerGetBlockHeaderRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetBlockHeader(ctx context.Context, request LiteServerGetBlockHeaderRequest) (res LiteServerBlockHeaderC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockHeaderRequest `tlSumType:"21ec069e"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x752d8219 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerSendMessageRequest struct {
	Body []byte
}

func (t LiteServerSendMessageRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Body)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerSendMessage(ctx context.Context, request LiteServerSendMessageRequest) (res LiteServerSendMsgStatusC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerSendMessageRequest `tlSumType:"690ad482"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x3950e597 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAccountStateRequest struct {
	Id      TonNodeBlockIdExtC
	Account LiteServerAccountIdC
}

func (t LiteServerGetAccountStateRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetAccountState(ctx context.Context, request LiteServerGetAccountStateRequest) (res LiteServerAccountStateC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAccountStateRequest `tlSumType:"6b890e25"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x7079c751 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAccountStatePrunnedRequest struct {
	Id      TonNodeBlockIdExtC
	Account LiteServerAccountIdC
}

func (t LiteServerGetAccountStatePrunnedRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetAccountStatePrunned(ctx context.Context, request LiteServerGetAccountStatePrunnedRequest) (res LiteServerAccountStateC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAccountStatePrunnedRequest `tlSumType:"5a698507"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x7079c751 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerRunSmcMethodRequest struct {
	Mode     uint32
	Id       TonNodeBlockIdExtC
	Account  LiteServerAccountIdC
	MethodId uint64
	Params   []byte
}

func (t LiteServerRunSmcMethodRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.MethodId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Params)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerRunSmcMethod(ctx context.Context, request LiteServerRunSmcMethodRequest) (res LiteServerRunMethodResultC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerRunSmcMethodRequest `tlSumType:"5cc65dd2"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa39a616b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetShardInfoRequest struct {
	Id        TonNodeBlockIdExtC
	Workchain uint32
	Shard     uint64
	Exact     bool
}

func (t LiteServerGetShardInfoRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Exact)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetShardInfo(ctx context.Context, request LiteServerGetShardInfoRequest) (res LiteServerShardInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetShardInfoRequest `tlSumType:"46a2f425"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x9fe6cd84 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAllShardsInfoRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetAllShardsInfoRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetAllShardsInfo(ctx context.Context, request LiteServerGetAllShardsInfoRequest) (res LiteServerAllShardsInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAllShardsInfoRequest `tlSumType:"74d3fd6b"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x98fe72d {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetOneTransactionRequest struct {
	Id      TonNodeBlockIdExtC
	Account LiteServerAccountIdC
	Lt      uint64
}

func (t LiteServerGetOneTransactionRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetOneTransaction(ctx context.Context, request LiteServerGetOneTransactionRequest) (res LiteServerTransactionInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetOneTransactionRequest `tlSumType:"d40f24ea"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xedeed47 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetTransactionsRequest struct {
	Count   uint32
	Account LiteServerAccountIdC
	Lt      uint64
	Hash    tl.Int256
}

func (t LiteServerGetTransactionsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Hash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetTransactions(ctx context.Context, request LiteServerGetTransactionsRequest) (res LiteServerTransactionListC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetTransactionsRequest `tlSumType:"1c40e7a1"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x6f26c60b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerLookupBlockRequest struct {
	Mode  uint32
	Id    TonNodeBlockIdC
	Lt    *uint64
	Utime *uint32
}

func (t LiteServerLookupBlockRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Utime)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerLookupBlock(ctx context.Context, request LiteServerLookupBlockRequest) (res LiteServerBlockHeaderC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerLookupBlockRequest `tlSumType:"fac8f71e"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x752d8219 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerLookupBlockWithProofRequest struct {
	Mode      uint32
	Id        TonNodeBlockIdC
	McBlockId TonNodeBlockIdExtC
	Lt        *uint64
	Utime     *uint32
}

func (t LiteServerLookupBlockWithProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.McBlockId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Utime)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerLookupBlockWithProof(ctx context.Context, request LiteServerLookupBlockWithProofRequest) (res LiteServerLookupBlockResultC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerLookupBlockWithProofRequest `tlSumType:"9c045ff8"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x57c7ccc5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerListBlockTransactionsRequest struct {
	Id    TonNodeBlockIdExtC
	Mode  uint32
	Count uint32
	After *LiteServerTransactionId3C
}

func (t LiteServerListBlockTransactionsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>7)&1 == 1 {
		b, err = tl.Marshal(t.After)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerListBlockTransactions(ctx context.Context, request LiteServerListBlockTransactionsRequest) (res LiteServerBlockTransactionsC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerListBlockTransactionsRequest `tlSumType:"adfcc7da"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xbd8cad2b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerListBlockTransactionsExtRequest struct {
	Id    TonNodeBlockIdExtC
	Mode  uint32
	Count uint32
	After *LiteServerTransactionId3C
}

func (t LiteServerListBlockTransactionsExtRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>7)&1 == 1 {
		b, err = tl.Marshal(t.After)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerListBlockTransactionsExt(ctx context.Context, request LiteServerListBlockTransactionsExtRequest) (res LiteServerBlockTransactionsExtC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerListBlockTransactionsExtRequest `tlSumType:"0079dd5c"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xfb8ffce4 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockProofRequest struct {
	Mode        uint32
	KnownBlock  TonNodeBlockIdExtC
	TargetBlock *TonNodeBlockIdExtC
}

func (t LiteServerGetBlockProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.KnownBlock)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.TargetBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetBlockProof(ctx context.Context, request LiteServerGetBlockProofRequest) (res LiteServerPartialBlockProofC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockProofRequest `tlSumType:"8aea9c44"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x8ed0d2c1 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetConfigAllRequest struct {
	Mode uint32
	Id   TonNodeBlockIdExtC
}

func (t LiteServerGetConfigAllRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetConfigAll(ctx context.Context, request LiteServerGetConfigAllRequest) (res LiteServerConfigInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetConfigAllRequest `tlSumType:"911b26b7"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xae7b272f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetConfigParamsRequest struct {
	Mode      uint32
	Id        TonNodeBlockIdExtC
	ParamList []uint32
}

func (t LiteServerGetConfigParamsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ParamList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetConfigParams(ctx context.Context, request LiteServerGetConfigParamsRequest) (res LiteServerConfigInfoC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetConfigParamsRequest `tlSumType:"2a111c19"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xae7b272f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetValidatorStatsRequest struct {
	Mode          uint32
	Id            TonNodeBlockIdExtC
	Limit         uint32
	StartAfter    *tl.Int256
	ModifiedAfter *uint32
}

func (t LiteServerGetValidatorStatsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Limit)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.StartAfter)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.ModifiedAfter)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetValidatorStats(ctx context.Context, request LiteServerGetValidatorStatsRequest) (res LiteServerValidatorStatsC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetValidatorStatsRequest `tlSumType:"091a58bc"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xb9f796d8 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetLibrariesRequest struct {
	LibraryList []tl.Int256
}

func (t LiteServerGetLibrariesRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.LibraryList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetLibraries(ctx context.Context, request LiteServerGetLibrariesRequest) (res LiteServerLibraryResultC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetLibrariesRequest `tlSumType:"d122b662"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x117ab96b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetLibrariesWithProofRequest struct {
	Id          TonNodeBlockIdExtC
	Mode        uint32
	LibraryList []tl.Int256
}

func (t LiteServerGetLibrariesWithProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.LibraryList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetLibrariesWithProof(ctx context.Context, request LiteServerGetLibrariesWithProofRequest) (res LiteServerLibraryResultWithProofC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetLibrariesWithProofRequest `tlSumType:"8c026c31"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x99370a1f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetShardBlockProofRequest struct {
	Id TonNodeBlockIdExtC
}

func (t LiteServerGetShardBlockProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetShardBlockProof(ctx context.Context, request LiteServerGetShardBlockProofRequest) (res LiteServerShardBlockProofC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetShardBlockProofRequest `tlSumType:"4ca60350"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x1d62a07a {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetOutMsgQueueSizesRequest struct {
	Mode  uint32
	Wc    *uint32
	Shard *uint64
}

func (t LiteServerGetOutMsgQueueSizesRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Wc)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Shard)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetOutMsgQueueSizes(ctx context.Context, request LiteServerGetOutMsgQueueSizesRequest) (res LiteServerOutMsgQueueSizesC, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetOutMsgQueueSizesRequest `tlSumType:"7bc19c36"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerErrorC
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xf8504a03 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}
